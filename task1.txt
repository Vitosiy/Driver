02.11.2020

.kdfiles -m \??\C:\Documents\root\Desktop\Driver1\Driver.sys C:\Users\Vitaliy\Desktop\Univer\Sysprog\sysprog2\driver_hook-master\objchk_wxp_x86\i386\Driver.sys

Написать драйвер и программу управления драйвером. Программа должна осуществлять запуск/останов драйвера, взаимодействие с пользователем и взаимодействие с драйвером: посылать команды и получать результат.

n - номер студента в списке (ориентироваться на список с оценками). = 3
a=11
b=13

Необходимо выбрать от 2 до 5 задач из указанных ниже. Выполнение задачи подразумевает взаимодействие программы и драйвера через некоторый интерфейс. Типы интерфейсов представлены ниже. Для i-ой задачи тип интерфейса для её подзадач равен (n*a+i*b)%6.
Если потребуется использовать какой-то тип интерфейса несколько раз (для разных задач или для разных подзадач в рамках одной задачи), то в рамках этого типа необходимо реализовать отдельный интерфейс (отдельные системные вызовы, прерывания и др.) для каждой реализуемой подзадачи (а не реализовывать один, к примеру, системный вызов, который с помощью отдельного аргумента будет определять запрашиваемую подзадачу). Если для определения конкретного интерфейса (например, номера прерывания) требует номер подзадачи, то самостоятельно упорядочить и пронумеровать (с 0) все подзадачи, требующие этого типа интерфейса.


Типы интерфейсов взаимодействия программы с драйвером:
+0) ioctl-запросы к устройству драйвера. Разные ioctl-коды для разных подзадач.+
1) Запросы на чтение и запись к "файлам" устройства драйвера. Разные имена "файлов" для разных подзадач.+
+2) Перехват прерывания с помощью модификации соответствующего шлюза (прерывания) в IDT: заменять системный обработчик на свой, который будет выполнять запрошенную функциональность и возвращать управление программе либо передавать управление системному обработчику. Признаком обращения к интерфейсу (а не просто случайной генерации исключения) может служить уникальное значение в регистре. Для i-ой подзадачи перехватывать прерывание с номером 0x30+5*n+i.
+3) Добавление системного вызова в существующий дескриптор в таблицах KeServiceDescriptorTable и KeServiceDescriptorTableShadow. Системные вызовы с номерами 0-0xFFF добавляются в нулевой дескриптор, с номерами 0x1000-0x1FFF - в первый. Для i-ой подзадачи реализовать системный вызов с номером 0x1000*(i%2)+500+((n*a+i*b)%37).
+4) Добавление системного вызова в новый дескриптор (с номерами 2,3) в таблицы KeServiceDescriptorTable и KeServiceDescriptorTableShadow. Системные вызовы с номерами 0x2000-0x2FFF добавляются во второй дескриптор, с номерами 0x3000-0x3FFF - в третий. Для i-ой подзадачи реализовать системный вызов с номером 0x1000*(2+i%2)+((n*a+i*b)%37).
+5) Добавить шлюз вызова в GDT (при необходимости, создать новую большую GDT). Для i-ой подзадачи добавить шлюз в элемент GDT с индексом 300+((n*a+i*b)%37).+



Задачи:
+0) Дамп GDT и IDT. Программа должна получить от драйвера содержимое GDT и IDT, отобразить подробную информацию о каждом дескрипторе. Две подзадачи: дамп GDT, дамп IDT.
3 балла. (###interface:3 index0: 0x215, index1: 0x11df###) 
+1) Перехват всех прерываний с помощью модификации шлюзов в IDT (тип шлюзов меняться не должен). Для каждого прерывания должен вестись счетчик количества срабатываний этого прерывания. Программа запрашивает эту информацию у драйвера и отображает для каждого прерывания его счетчик. Две подзадачи: активация/деактивация перехвата, запрос информации. (###interface:4 index0: 0x2021, index1: 0x3009###) +
5 баллов.
+2) Перехват всех прерываний с помощью модификации шлюзов в IDT (тип шлюзов меняться не должен). Для каждого прерывания хранить регистровый контекст на момент каждого срабатывания прерывания (необходимо реализовать соответствующие контейнеры). Для исключений класса fault сохранять еще и инструкцию, вызвавшую исключение. Программа запрашивает эту информацию у драйвера и отображает. Две подзадачи: активация/деактивация перехвата, запрос информации. (###interface:5, index0: 333, index1:309###) +
5 баллов.
+3) Перехват обработчика инструкции sysenter. Для каждого системного вызова (индекс которого передается в eax) сохранять аргументы каждого обращения к этому системному вызову (необходимо реализовать соответствующие контейнеры). Программа запрашивает эту информацию у драйвера и отображает. Две подзадачи: активация/деактивация перехвата, запрос информации.
5 баллов. (###interface:0###) +
4) Чтение/запись физической памяти (без PAE и с PAE). Драйвер должен предоставлять интерфейс, позволяющий указать адрес и размер читаемой/записываемой памяти. Для демонстрации завести в программе уникальную строку, сканированием всей физической памяти найти ее физический адрес, изменить ее по этому адресу и вывести эту строку в программе (она должна измениться). Две подзадачи: чтение по указанному адресу, запись по указанному адресу.
5 баллов. (###interface:1###) 
+5) Чтение портов ввода/вывода. Драйвер должен предоставлять интерфейс, позволяющий указать адрес в пространстве ввода/вывода (номер порта) и количество считываемых байт. Программа должна выводить шестнадцатиричный дамп пространства ввода/вывода (размером 64 КБ). Одна подзадача: чтение по указанному адресу.
3 балла. (###interface:2 index0: 0x3f###) 



Могут быть полезны материалы занятий:
lab\1
lab\2



Пример кода для определения номеров

n = 3
a = 11
b = 13
for task_index in range(6):
	print('interface index: ' + str((n * a + task_index * b) % 6))

for subtask_index in range(2):
	print('subtask ' + str(subtask_index))
        print('2 syscall index: ' + hex(0x30 + 5 * n + subtask_index))
        print('3 syscall index: ' + hex(0x1000 * (subtask_index % 2) + 500 + ((n * a + subtask_index * b) % 37)))
        print('4 syscall index: ' + hex(0x1000 * (2 + subtask_index % 2) + ((n * a + subtask_index * b) % 37)))
        print('5 idt index: ' + str(300 + ((n * a + subtask_index * b) % 37)))


РЕЗУЛЬТАТ КОДА:
interface index: 3
interface index: 4
interface index: 5
interface index: 0
interface index: 1
interface index: 2

subtask 0
2 syscall index: 0x3f
3 syscall index: 0x215
4 syscall index: 0x2021
5 idt index: 333

subtask 1
2 syscall index: 0x40
3 syscall index: 0x11df
4 syscall index: 0x3009
5 idt index: 309

